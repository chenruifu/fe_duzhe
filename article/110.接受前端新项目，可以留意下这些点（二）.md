## 通用的功能要封装成组件

通用的组件，最好确定好功能点后，封装成统一的通用组件，通用组件一定要覆盖大部分的通用功能点，否则还不如不要

大一点的，例如弹窗，可能包括标题、关闭按钮、内容、遮罩层这些结构，小一点的，例如页面的遮罩层，主体包括一层遮罩样式,那在封装这个组件的时候，就要把这些结构考虑进去

我曾经看到过某个组件中，包含了多个弹窗，但是没有封装通用的弹窗组件，于是相同的元素以及样式被写了好几遍，印象最深刻的是遮罩层元素也出现了好几遍，每个弹窗都专门写一个遮罩层样式，写过的人都知道，单是这一个遮罩层的样式都有好几行了，何苦来哉

### DRY原则

**Don't repeat yourself**

这一条可以与上条结合使用，无论你是写什么代码，需求是长期还是短期的，作为一个有素质的程序猿，你最好都要遵守这条规则

这里的 DRY，不仅是指完全一模一样的代码字母，还在于同样的逻辑，这里举个例子，表单验证是很常见的场景，一般的验证方法都是不假思索的数个乃至是数十个 if语句依次排列，整整齐齐气势惊人，但问题是几个 if语句连在一起或许不太明显，难以触碰到你的 G点，但是十几个乃至是几十个 if语句堆在一起，你难道还能不觉得别扭吗？

```js
if (age > 19) {
  // ...
}
if (name.indexOf('zhao')) {
  // ...
}
if (gender === 1) {
  // ...
}
if (weight > 75) {
  // ...
}
// 无穷无尽
// ...
```

> 只要我复制粘贴得足够快，bug就追不上我

关于表单验证这个东西，[有篇文章](https://github.com/jawil/blog/issues/19)写得很好，大家可以参考一下

## 单独的业务代码之间、业务代码与非业务代码之间进行必要的隔离

业务代码，以 `if...else` 琳琅满目为主要标志之一，多个需求的业务代码混合在一起那就意味着数倍琳琅满目的 `if...else` ，如果再在这些 `if...else` 中躲猫猫般穿插进非业务代码，那么恭喜你，如今你得到的这份代码，其实有个流传于江湖已久的响当当名号：意大利面条式代码

隔离单独的业务代码，能够直接减少头发掉落数，能间接降低 bug出现率，这很好理解

一般的项目都是长期迭代而来，一个页面上可能堆积了数十个需求的功能点，每个功能点都对应几大段的方法和数据，并且这些需求还可能从诞生到现在被修改了数次，搞不好有的业务间还存在相互依赖与重叠

如果把这些业务包含的方法和数据全都放在一起，那酸爽……诶，这个方法是属于A需求的吗？如果是那为什么这里面还包含了B需求的数据？怎么这里还调用了C需求的方法？C需求的这个方法修改的这个数据是C需求的吗？看起来不太像啊？算了算了，应该是，先这样写吧，等测试提 bug了再说……

> 下班晚不是因为你需求多，而是你自己写得代码给你找的事多

## 与位置无关的元素聚集书写

如果页面上元素少的话，或许没有区别，但是当页面上存在大量元素，例如网站首页、商品详情页这些比较重要的页面，就很容易感觉出来了

像 modal弹窗、toast等辅助性元素，页面上可能存在好多个，这种元素一般与位置无关，样式设置的都是 `position: asbolute`或者 `position: fixed`;，无论放在哪个位置基本上都 ok，那么建议找好一个固定的位置聚集存放这些元素，例如页面的顶部或者底部，并写好注释，方便寻找与修改，也方便统计，任意穿插在各种 DOM间，维护起来都是一件麻烦事

```js
<!-- 新手好礼的引导弹窗 -->
<ModalA />
<!-- 领奖弹窗 -->
<ModalB />
<!-- 新人提示 -->
<ToastA />
<!-- 资质不够提示 -->
<ToastB />
<!-- 风险用户提示 -->
<ToastC />
```

## 删掉不必要的代码

包括无效代码、注释的代码、不必要的调试代码

做过活动页的应该都知道，这种活动运营页寿命一般都很短，但是所要付出的精力却不少，活动下线后代码可能就直接无效了，大部分情况下这些失效的活动代码不会对页面有效逻辑产生什么影响，所以赶着进入下一个需求的程序猿们，本着多一事不如少一事的原则，很可能就任由无效代码一直存在于页面，直到地老天荒，这种事情最起码从我的经历来看，很常见

有的需求在开发阶段频繁变动，辛辛苦苦写的逻辑还没来得及被上传到线上服务器就夭折了，恼羞成怒的程序猿不甘心掉落的头发连一点成果都没有留下，于是机智地按下了 `Ctrl + /` 快捷键，幻想着这段被封印的代码总有重见天日的那天，殊不知，又是直到地老天荒，这种事情最起码从我的经历来看，很常见

虽然某些自动化打包编译工具支持删除类似于 `console.log`、`debugger` 之类的调试代码，但问题是在 dev阶段这些代码都是存在的，每个人在每个需求中都加入 5个 `console.log`，那么只需要十个人次，控制台上就可以出现 50行 `console.log`，特别是这些 `console.log` 基本上都是秉持着哪里有位置就写在哪里的原则，就算是想删也需要耗费大量时间，苦逼的程序猿什么都没干，先在控制台看到几十行别人写的 `console.log`，然后在一堆 `console.log`中找到自己需要的那个，并在需求完成时，顺便又在原先几十个 `console.log`的基础上，又贡献了自己的一份力量，这种事情最起码从我的经历来看，很常见

> 编辑器每多显示一行无效代码、控制台每多输出一行 console.log，都将耗费一定的电量，全球几千万的程序员，积少成多，足以加重全球温室效应，加速两级冰川融化，可怜的北极熊宝宝和企鹅宝宝找不到爸爸妈妈，人间有真情人间有真爱，请坚定地按下 backspace 或 delete吧

## 良好的沟通，避免无效的产出

> 永远不要相信 PM说的这个需求肯定不会再变了的话

PM改变需求我们无法劝阻，但是我们可以明确现有的需求，不写无效的代码，从而进一步避免了大段注释，保住了更多的头发，不要等到快上线的时候，才发现自己好像弄错了某段逻辑，或者少写了某段逻辑，最可恨的是白写了某段逻辑

## 代码容错

这个世界上不存在没有 Bug的代码，只要你写的不是 demo，那么一定要做好代码容错处理，因为你永远不知道接口给你返回的是 | 还是 丨(亲身经历，此梗参见有哪些让你目瞪口呆的 bug？)

还有一些可能不叫错误，例如页面数据的初始化，在获取到数据之前，页面上可能会渲染出 undefined这种鬼东西，为了更好的用户体验，最好还是给个体验更好的初始值吧

## 遵守制定好的规范

多人协作规范很重要，无论是 jshint 还是eslint大行其道就是明证

，对于一个项目来说，规范可能包括从 es版本、缩进类型到页面结构、组件拆分等，你既可以直接照抄成熟的规范，也可以自定义规范，但无论是什么样的规范，只要制定下来，那就要遵守，不要因个人原因，与团队貌合神离

有种效应叫破窗效应，这个项目中出现了不一样的风格，后来进入的人第一印象就是规范也不是那么严谨，偶尔打破一下也是可以的，然后又有后来的人看到，第一印象就是……于是不同的风格越积越多，规范也就无从谈起了，从一开始就稳不住，难道还想着半路突然硬一下？

你可以不喜欢项目现在的页面结构划分方式，也可以认为路由的划分方式很SB，但既然你在当初制定这个规范时没有反对没有提出异议(无论是忘记了还是被无视还是没有机会提，总之当初你没反对)，那么现在就要遵守，或者你也可以尝试着改变这个规范，但请做好善后事宜，例如确保在新规范制定后，项目中之前存在的老规范要被全部修改过来，坚决保证代码风格统一化，至于是谁来做这种吃力不讨好的事情，你懂得。

> 自己挑的shi，跪着也要吃完

## 定期的代码 review

旁观者清，自己一般很难发现自己的错误，否则的话也不会那么容易触犯了，无论是代码的规范还是逻辑的偏差，有些错误如果其他人不及时指出来，我们可能永远无法意识到，定期的代码 review就能够很好地解决这个问题

不过，代码虽好，也没必要 review得太频繁了，不然只会变成一种负担，大家都这么忙，谁没事帮你天天 review代码

## 必要的踩坑与经验文档

这个 **很重要**，无论你用的是什么框架，写的是小程序还是 webview，肯定都存在着各种各样的坑，如果老旧代码有历史包袱不想搞的话，那么新启项目就要好好对待了，文档该写的就要写，不要怕麻烦，不过等到新人加入，或者干脆是移交他人的时候，你就知道什么叫 **敲码一时爽，交接火葬场了**

## 小结

曾经看到过某个帖子，大意是 题主认为大部分前端做的事情，其实无论是五年经验还是外包或者实习生都能做，凭什么五年经验人拿得工资就高？

我当时也是闲得蛋疼，回答：这个问题不仅仅是在前端，后端、客户端等各种领域都会给你这种错觉，我以前也是这么认为的，后来某天当我看到一个相同的 bug，组长看了一眼就准确定位并顺手解决，而实习生抓耳挠腮了大半天，不仅没能明白到底是怎么回事，甚至还多引入了几个 bug后，我就知道人家那么多钱不是白拿的

当然，大部分工作经验高拿钱多的人并不是仅仅是靠改 bug快这一个原因，另外也不排除有些人本来就天赋异禀，只工作了一年但能力抵得上别人工作三年的，而有些人工作三年只有一年的能力

>作者：清夜<br/>链接：https://juejin.im/post/5b99c824f265da0ac55e3980